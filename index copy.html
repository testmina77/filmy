<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Videos from ./videos — Player</title>
<style>
  :root{ --bg:#0b0c10; --card:#101215; --muted:#9aa0a6; --accent:#5ad0ff; --radius:10px; --gap:12px; }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#07080a,#0b0c10);color:#eaf6ff;padding:18px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:16px}
  h1{font-size:18px;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer}
  button.primary{background:linear-gradient(90deg,#062235,#043b5a);border:1px solid rgba(90,208,255,0.12)}
  .wrap{max-width:1200px;margin:0 auto}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:var(--gap)}
  .card{background:var(--card);border-radius:10px;overflow:hidden;cursor:pointer;border:1px solid rgba(255,255,255,0.02);transition:transform .12s,box-shadow .12s}
  .card:hover{transform:translateY(-6px);box-shadow:0 14px 30px rgba(0,0,0,0.5)}
  .thumb{height:110px;background:linear-gradient(180deg,#0b0d11,#0e1115);display:flex;align-items:center;justify-content:center;position:relative}
  .thumb img{width:100%;height:110px;object-fit:cover;display:block}
  .meta{padding:10px;font-size:13px}
  .title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .sub{color:var(--muted);font-size:12px;margin-top:6px}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);z-index:60;padding:20px}
  .modal.open{display:flex}
  .player-box{width:min(1100px,95%);background:#071018;border-radius:10px;padding:12px}
  video{width:100%;height:auto;border-radius:8px;background:black}
  .row{display:flex;gap:8px;align-items:center}
  .status{color:var(--muted);font-size:13px}
  .empty{padding:28px;border-radius:10px;background:rgba(255,255,255,0.02);text-align:center;color:var(--muted)}
  select{background:transparent;border:1px solid rgba(255,255,255,0.03);color:inherit;padding:6px;border-radius:8px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Galeria — katalog <code>./videos/</code></h1>
      <div class="controls">
        <button id="refreshBtn" class="primary">⭮ Odśwież</button>
        <label class="row status" id="status">Ładowanie…</label>
        <select id="sortSelect" title="Sortuj">
          <option value="name">Sortuj: nazwa ⬆</option>
          <option value="name-desc">Sortuj: nazwa ⬇</option>
          <option value="size">Sortuj: rozmiar ⬆</option>
          <option value="size-desc">Sortuj: rozmiar ⬇</option>
          <option value="duration">Sortuj: czas ⬆</option>
          <option value="duration-desc">Sortuj: czas ⬇</option>
        </select>
      </div>
    </header>

    <main>
      <div id="empty" class="empty" style="display:none">Brak plików. Upewnij się, że katalog <code>./videos/</code> istnieje i zawiera pliki .mp4 lub udostępnił listing katalogu, albo dodaj <code>manifest.json</code>.</div>
      <div id="grid" class="grid" aria-live="polite"></div>
    </main>
  </div>

  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="player-box">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div><strong id="modalTitle">Tytuł</strong><div id="modalMeta" style="color:var(--muted);font-size:13px"></div></div>
        <div><button id="closeBtn">✕ Zamknij</button></div>
      </div>
      <video id="videoPlayer" controls playsinline></video>
    </div>
  </div>

<script>
(async function(){
  const grid = document.getElementById('grid');
  const status = document.getElementById('status');
  const empty = document.getElementById('empty');
  const refreshBtn = document.getElementById('refreshBtn');
  const sortSelect = document.getElementById('sortSelect');
  const modal = document.getElementById('modal');
  const videoPlayer = document.getElementById('videoPlayer');
  const modalTitle = document.getElementById('modalTitle');
  const modalMeta = document.getElementById('modalMeta');
  const closeBtn = document.getElementById('closeBtn');

  // base path: ./videos/ resolved relative to current page
  const baseVideosUrl = new URL('./videos/', location.href).href; // resolves correctly for pages in subfolders

  // library holds objects: {name, url, size (bytes|null), duration (sec|null), thumb (dataURL|null)}
  let library = [];

  async function fetchManifest(){
    try{
      const res = await fetch(new URL('manifest.json', baseVideosUrl).href, {cache:'no-store'});
      if(!res.ok) return null;
      const json = await res.json();
      if(Array.isArray(json)) return json; // expect ['a.mp4','b.mp4']
      return null;
    }catch(e){
      return null;
    }
  }

  async function fetchDirectoryListing(){
    // try to fetch the directory page and parse links to .mp4
    try{
      const res = await fetch(baseVideosUrl, {cache:'no-store'});
      if(!res.ok) return null;
      const text = await res.text();
      // parse hrefs - simple regex to capture href="..."
      const hrefs = Array.from(text.matchAll(/href\s*=\s*["']([^"']+)["']/gi)).map(m=>m[1]);
      const mp4s = hrefs.filter(h => h.toLowerCase().endsWith('.mp4')).map(h => decodeURIComponent(h.split('?')[0].split('#')[0]));
      // dedupe and normalize names (keep basename)
      const names = Array.from(new Set(mp4s.map(h => h.replace(/\/+$/, '').split('/').pop())));
      return names;
    }catch(e){
      return null;
    }
  }

  // utility human size
  function humanSize(bytes){
    if(!bytes && bytes !== 0) return '—';
    if(bytes < 1024) return bytes + ' B';
    const units=['KB','MB','GB','TB'];
    let i = -1; let b = bytes;
    do{ b = b / 1024; i++; } while(b >= 1024 && i < units.length-1);
    return b.toFixed(b>=10?0:1) + ' ' + units[i];
  }

  function formatDuration(sec){
    if(!sec && sec !== 0) return '—';
    const s = Math.floor(sec%60).toString().padStart(2,'0');
    const m = Math.floor((sec/60)%60).toString().padStart(2,'0');
    const h = Math.floor(sec/3600);
    return h ? `${h}:${m}:${s}` : `${m}:${s}`;
  }

  async function makeThumbnail(videoUrl){
    // create a <video> element, load metadata, seek, draw to canvas
    return new Promise((resolve)=>{
      const v = document.createElement('video');
      v.preload = 'metadata';
      v.src = videoUrl;
      v.muted = true;
      // In many servers Range requests are supported so browser won't download entire file
      v.addEventListener('loadedmetadata', () => {
        const dur = v.duration || 0;
        const seekTo = Math.min(2, Math.max(0.1, dur/3));
        const onSeeked = () => {
          try{
            const canvas = document.createElement('canvas');
            const w = 320; const h = Math.round(w * 9 / 16);
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(v, 0, 0, w, h);
            const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
            resolve({thumb:dataUrl, duration: dur});
          }catch(e){
            resolve({thumb:null, duration: dur});
          } finally {
            v.removeAttribute('src'); v.load();
          }
        };
        v.currentTime = seekTo;
        v.addEventListener('seeked', onSeeked, {once:true});
        // safety fallback
        setTimeout(()=>{ try{ if(!v.seeking){ /* already done */ } }catch(e){} }, 2500);
      });
      v.addEventListener('error', ()=> resolve({thumb:null, duration:null}));
    });
  }

  async function statFile(url){
    // try to get size via HEAD
    try{
      const res = await fetch(url, {method:'HEAD'});
      if(!res.ok) return null;
      const size = res.headers.get('content-length');
      return size ? parseInt(size,10) : null;
    }catch(e){ return null; }
  }

  async function loadLibrary(){
    status.textContent = 'Szukam plików…';
    library = [];

    // 1) manifest.json
    const manifest = await fetchManifest();
    let names = null;
    if(Array.isArray(manifest) && manifest.length){
      names = manifest.filter(n => n.toLowerCase().endsWith('.mp4'));
    } else {
      // 2) try directory listing parse
      const parsed = await fetchDirectoryListing();
      if(Array.isArray(parsed) && parsed.length) names = parsed;
    }

    if(!names || !names.length){
      status.textContent = 'Brak plików .mp4 w ./videos/';
      empty.style.display = 'block';
      grid.innerHTML = '';
      return;
    }

    empty.style.display = 'none';
    status.textContent = `Znaleziono ${names.length} plików — generuję miniaturek...`;

    // build objects and progressively render
    for(const name of names){
      const url = new URL(name, baseVideosUrl).href;
      const item = {name, url, size: null, duration: null, thumb: null};
      library.push(item);
      renderGrid(); // show placeholder early
      // fetch HEAD for size
      const size = await statFile(url);
      if(size) item.size = size;
      // generate thumb+duration
      try{
        const res = await makeThumbnail(url);
        if(res.thumb) item.thumb = res.thumb;
        if(res.duration) item.duration = res.duration;
      }catch(e){}
      renderGrid();
    }

    status.textContent = `${library.length} plików załadowanych`;
  }

  function renderGrid(){
    grid.innerHTML = '';
    if(!library.length) return;
    // apply sorting
    const mode = sortSelect.value;
    const list = [...library].sort((a,b)=>{
      switch(mode){
        case 'name': return a.name.localeCompare(b.name);
        case 'name-desc': return b.name.localeCompare(a.name);
        case 'size': return (a.size||0) - (b.size||0);
        case 'size-desc': return (b.size||0) - (a.size||0);
        case 'duration': return (a.duration||0) - (b.duration||0);
        case 'duration-desc': return (b.duration||0) - (a.duration||0);
        default: return 0;
      }
    });

    for(const item of list){
      const card = document.createElement('div'); card.className='card';
      const thumb = document.createElement('div'); thumb.className='thumb';
      if(item.thumb){
        const img = document.createElement('img'); img.src = item.thumb; img.alt = item.name; thumb.appendChild(img);
      } else {
        const ph = document.createElement('div'); ph.style.color = 'var(--muted)'; ph.style.fontSize='13px'; ph.textContent = 'Generuję miniaturkę…';
        thumb.appendChild(ph);
      }
      const meta = document.createElement('div'); meta.className='meta';
      const title = document.createElement('div'); title.className='title'; title.textContent = item.name;
      const sub = document.createElement('div'); sub.className='sub'; sub.textContent = `${formatDuration(item.duration)} • ${item.size?humanSize(item.size):'—'}`;
      meta.appendChild(title); meta.appendChild(sub);
      card.appendChild(thumb); card.appendChild(meta);

      card.addEventListener('click', ()=> openPlayer(item));
      grid.appendChild(card);
    }
  }

  function openPlayer(item){
    modalTitle.textContent = item.name;
    modalMeta.textContent = `${formatDuration(item.duration)} • ${item.size?humanSize(item.size):'—'}`;
    videoPlayer.src = item.url;
    videoPlayer.currentTime = 0;
    modal.classList.add('open');
    setTimeout(()=> videoPlayer.play().catch(()=>{}),100);
  }

  function closeModal(){
    videoPlayer.pause();
    videoPlayer.removeAttribute('src'); videoPlayer.load();
    modal.classList.remove('open');
  }

  // events
  refreshBtn.addEventListener('click', ()=> loadLibrary());
  sortSelect.addEventListener('change', renderGrid);
  closeBtn.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=> { if(e.target === modal) closeModal(); });
  document.addEventListener('keydown', (e)=> { if(e.key === 'Escape') closeModal(); });

  // initial load
  await loadLibrary();
})();
</script>
</body>
</html>
